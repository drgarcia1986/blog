<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Diego Garcia - Docker</title><link href="https://drgarcia1986.github.io/blog/" rel="alternate"></link><link href="https://drgarcia1986.github.io/blog/docker.atom.xml" rel="self"></link><id>https://drgarcia1986.github.io/blog/</id><updated>2015-05-01T11:05:00-03:00</updated><entry><title>Executando uma aplicação WSGI com Docker</title><link href="https://drgarcia1986.github.io/blog/2015/05/01/executando-uma-aplicacao-wsgi-com-docker/" rel="alternate"></link><published>2015-05-01T11:05:00-03:00</published><updated>2015-05-01T11:05:00-03:00</updated><author><name>Diego Garcia</name></author><id>tag:drgarcia1986.github.io,2015-05-01:/blog/2015/05/01/executando-uma-aplicacao-wsgi-com-docker/</id><summary type="html">&lt;p&gt;Já sabemos um pouco sobre o Docker, como ele funciona e como podemos brincar com ele.
Porém, na prática, como podemos conteinerizar nossas aplicações de forma simples e com um bom desempenho?
Veremos nesse post uma &lt;em&gt;receita de bolo&lt;/em&gt; de como conteinerizar aplicações WSGI de forma simples com um molde que pode ser reaproveitado sempre que necessário.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Já sabemos um pouco sobre o Docker, como ele funciona e como podemos brincar com ele.
Porém, na prática, como podemos conteinerizar nossas aplicações de forma simples e com um bom desempenho?
Veremos nesse post uma &lt;em&gt;receita de bolo&lt;/em&gt; de como conteinerizar aplicações WSGI de forma simples com um molde que pode ser reaproveitado sempre que necessário.&lt;/p&gt;


&lt;blockquote&gt;
&lt;p&gt;Esse post é a continuação do post &lt;a href="/docker-por-onde-comecar.html"&gt;Docker, por onde começar&lt;/a&gt;, recomendo que faça a leitura do post inicial (caso ainda não tenha feito) antes de prosseguir.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;A aplicação de exemplo&lt;/h3&gt;
&lt;p&gt;A idéia aqui não é criar uma aplicação complexa e perder tempo explicando como essa aplicação funciona, mas sim, criar uma estrutura que pode servir de molde para outras aplicações que irão rodar em containers (ou não).
Sendo assim, iremos criar a estrutura básica de uma aplicação que poderá ser usada como base para qualquer outra aplicação, independente do Framework, desde que tenha suporte a WSGI.&lt;/p&gt;
&lt;h4&gt;O arquivo RUN.py&lt;/h4&gt;
&lt;p&gt;O que vai realmente importar para o nosso exemplo é o arquivo &lt;code&gt;run.py&lt;/code&gt;, nele iremos carregar e disponibilizar o &lt;code&gt;wsgi&lt;/code&gt; do nosso app.
Basicamente esse será o arquivo que deverá ser chamado quando quisermos colocar nossa aplicação no ar.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;my_app&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;app&lt;/span&gt;


&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O arquivo &lt;code&gt;run.py&lt;/code&gt; é genérico, ou seja, funciona tanto para aplicações flask, bottle, falcon, etc.
Por exemplo, se estivessemos criando uma aplicação Flask, bastaria ter o seguinte código no arquivo &lt;code&gt;my_app.py&lt;/code&gt; (ou &lt;code&gt;my_app/__init__.py&lt;/code&gt;).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;flask&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Flask&lt;/span&gt;


&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Flask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="vm"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="nd"&gt;@app.route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;index&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Hello from docker!&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Já uma aplicação bottle, poderia ser dessa maneira.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;bottle&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;bottle&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;route&lt;/span&gt;


&lt;span class="nd"&gt;@route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;index&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Hello from docker!&amp;#39;&lt;/span&gt;


&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bottle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;default_app&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;E assim por diante.
Como falei anteriormente, a idéia é não se aprofundar na aplicação, mas sim na arquitetura.&lt;/p&gt;
&lt;h4&gt;Gunicorn&lt;/h4&gt;
&lt;p&gt;O &lt;a href="http://gunicorn.org/"&gt;Gunicorn&lt;/a&gt; é um servidor HTTP dedicado que serve aplicações WSGI, como é o caso de aplicações desenvolvidas com &lt;em&gt;Flask&lt;/em&gt;, &lt;em&gt;Django&lt;/em&gt;, &lt;em&gt;Bootle&lt;/em&gt;, etc.
Com o gunicorn é possível por exemplo executar uma aplicação wsgi com diversos &lt;code&gt;workers&lt;/code&gt; fazendo assim com que as requisições sejam divididas entre eles e como consequência, tornar a aplicação &lt;em&gt;mais robusta&lt;/em&gt;.
Utilizaremos o Gunicorn para controlar a instancia de nossa aplicação, com a seguinte &lt;em&gt;command line&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gunicorn -b &lt;span class="m"&gt;0&lt;/span&gt;.0.0.0:8000 -w &lt;span class="m"&gt;4&lt;/span&gt; run:app
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Com o comando acima, estamos liberando o acesso externo para a aplicação, estamos rodando a aplicação com 4 &lt;code&gt;workers&lt;/code&gt; e finalmente estamos definindo que o objeto WSGI que deverá ser executado é o objeto &lt;code&gt;app&lt;/code&gt; que se encontra no scritp &lt;code&gt;run.py&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Outra opção ao Gunicorn é o &lt;a href="https://uwsgi-docs.readthedocs.org/en/latest/"&gt;uWSGI&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Supervisor&lt;/h4&gt;
&lt;p&gt;O &lt;a href="http://supervisord.org/"&gt;Supervisor&lt;/a&gt; é um sistema de que monitora e controla processos unix.
O Supervisor garante que caso nossa aplicação finalize devido a alguma falha, ele se encarregará de subir novamente o processo, assim como subir o processo da aplicação caso o sistema operacional seja reiniciado.
Utilizaremos o Supervisor para controlar nosso processo do &lt;em&gt;Gunicorn&lt;/em&gt;, com as seguintes configurações.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[supervisord]&lt;/span&gt;
&lt;span class="na"&gt;nodaemon&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;true&lt;/span&gt;

&lt;span class="k"&gt;[program:my_app]&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;gunicorn -b 0.0.0.0:8000 -w 4 run:app&lt;/span&gt;
&lt;span class="na"&gt;directory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/my_app/&lt;/span&gt;
&lt;span class="na"&gt;autostart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;true&lt;/span&gt;
&lt;span class="na"&gt;autorestart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;true&lt;/span&gt;
&lt;span class="na"&gt;stdout_logfile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/my_app/logs/supervisor.log&lt;/span&gt;
&lt;span class="na"&gt;redirect_stderr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Basicamente estamos definindo a &lt;em&gt;command line&lt;/em&gt; de nossa aplicação e redirecionando a saída padrão e a saída de erro para um arquivo de log.&lt;/p&gt;
&lt;h3&gt;Conteinerizando a aplicação&lt;/h3&gt;
&lt;p&gt;Finalmente iremos colocar tudo isso dentro de uma imagem do Docker e executar como um container.
Veja um exemplo de como a estrutura do projeto pode ficar.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;├── my_app
│   └── __init__.py
├── requirements.txt
├── run.py
└── supervisord.conf
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;Não esqueça de criar o &lt;code&gt;requirements.txt&lt;/code&gt; com as dependências do seu projeto :)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Para a mágica acontecer, iremos criar nosso &lt;code&gt;Dockerfile&lt;/code&gt; na raiz do diretório do projeto.&lt;/p&gt;
&lt;h4&gt;Dockerfile&lt;/h4&gt;
&lt;p&gt;O intuito do Dockerfile será criar uma imagem do Docker com toda a stack que iremos utilizar no projeto, o código fonte da aplicação e uma configuração básica de execução, para que seja possível fácilmente executar a aplicação a partir de um container dessa imagem.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; python:2.7&lt;/span&gt;

&lt;span class="k"&gt;MAINTAINER&lt;/span&gt;&lt;span class="s"&gt; Diego Garcia &amp;lt;drgarcia1986@gmail.com&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;ADD&lt;/span&gt;&lt;span class="s"&gt; . /my_app&lt;/span&gt;
&lt;span class="k"&gt;ADD&lt;/span&gt;&lt;span class="s"&gt; supervisord.conf /etc/supervisor/conf.d/my_app.conf&lt;/span&gt;

&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; /my_app&lt;/span&gt;

&lt;span class="k"&gt;RUN&lt;/span&gt; pip install supervisor gunicorn
&lt;span class="k"&gt;RUN&lt;/span&gt; pip install -r requirements.txt

&lt;span class="k"&gt;RUN&lt;/span&gt; mkdir logs
&lt;span class="k"&gt;RUN&lt;/span&gt; touch logs/supervisor.log

&lt;span class="k"&gt;EXPOSE&lt;/span&gt;&lt;span class="s"&gt; 8000&lt;/span&gt;

&lt;span class="k"&gt;CMD&lt;/span&gt;&lt;span class="s"&gt; [&amp;quot;supervisord&amp;quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;Já existem as imagens do Python no repostórios padrão do &lt;a href="https://hub.docker.com/"&gt;DockerHub&lt;/a&gt; :)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pronto, já temos tudo que precisamos para containerizar nossa aplicação, sendo assim, &lt;code&gt;It's party time!&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Executando a aplicação via container&lt;/h3&gt;
&lt;h4&gt;Criar&lt;/h4&gt;
&lt;p&gt;Estrutura pronta e Dockerfile pronto, agora é a vez de criar a imagem docker da nossa aplicação, para isso, usaremos o comando &lt;code&gt;docker build&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo docker build -t my_app .
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Executar&lt;/h4&gt;
&lt;p&gt;Após o processo de criação da imagem, basta usar o comando &lt;code&gt;docker run&lt;/code&gt; para executar o container.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo docker run -d -p &lt;span class="m"&gt;8000&lt;/span&gt;:8000 my_app
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;A opção &lt;code&gt;-d&lt;/code&gt; está dizendo ao comando que queremos executar o container em background, enquanto que a opção &lt;code&gt;-p&lt;/code&gt; faz o mapeamento da porta 8000 do container com a porta 8000 local.
Você pode dar um nome para o container, para isso basta utilizar a opção &lt;code&gt;--name&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Com isso nossa aplicação finalmente está no ar em &lt;code&gt;127.0.0.1:8000&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;Listar&lt;/h4&gt;
&lt;p&gt;Para listar o containers que estão em execução, utilize o comando &lt;code&gt;docker ps&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo docker ps
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Parar&lt;/h4&gt;
&lt;p&gt;E por fim, para parar a execução de um container, existe o comando &lt;code&gt;docker stop&lt;/code&gt; que espera como parametro o &lt;em&gt;ID&lt;/em&gt; (que pode ser obtido através do comando &lt;code&gt;docker ps&lt;/code&gt;) ou nome do container.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo docker stop 80febff98649
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Conclusão&lt;/h3&gt;
&lt;p&gt;Vimos de uma forma simples e prática como criar um flow de conteinerização de aplicações python wsgi que pode ser reaproveitado sempre que necessário afim de agilizar bastante o processo de configuração e execução da aplicação.
Em um próximo post veremos um pouco sobre o &lt;strong&gt;docker compose&lt;/strong&gt; e como fazer o deploy de nossos containers na nuvem.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Referências&lt;/strong&gt;&lt;br&gt;
&lt;a href="https://www.docker.com/"&gt;Site Oficial&lt;/a&gt;&lt;br&gt;
&lt;a href="http://docs.docker.com/"&gt;Documentação oficial&lt;/a&gt;&lt;/p&gt;</content><category term="docker"></category><category term="devops"></category><category term="linux"></category><category term="python"></category></entry><entry><title>Docker, por onde começar</title><link href="https://drgarcia1986.github.io/blog/2015/02/15/docker-por-onde-comecar/" rel="alternate"></link><published>2015-02-15T10:32:26-02:00</published><updated>2015-02-15T10:32:26-02:00</updated><author><name>Diego Garcia</name></author><id>tag:drgarcia1986.github.io,2015-02-15:/blog/2015/02/15/docker-por-onde-comecar/</id><summary type="html">&lt;p&gt;Uma das grandes novidades da tecnologia que mais me chamaram a atenção ultimamente é o &lt;strong&gt;Docker&lt;/strong&gt;, essa poderosa ferramenta que veio para deixar qualquer devops feliz da vida.
Arrisco dizer que, nos próximos anos, se o Docker não acabar com a virtualização, essa só irá existir em conjunto com o Docker.
O projeto ainda está no começo mas já existem pessoas utilizando em produção.
Entenda um pouco sobre o que é o Docker e como você pode começar a utilizar em seu dia a dia.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Uma das grandes novidades da tecnologia que mais me chamaram a atenção ultimamente é o &lt;strong&gt;Docker&lt;/strong&gt;, essa poderosa ferramenta que veio para deixar qualquer devops feliz da vida.
Arrisco dizer que, nos próximos anos, se o Docker não acabar com a virtualização, essa só irá existir em conjunto com o Docker.
O projeto ainda está no começo mas já existem pessoas utilizando em produção.
Entenda um pouco sobre o que é o Docker e como você pode começar a utilizar em seu dia a dia.&lt;/p&gt;


&lt;h3&gt;Docker&lt;/h3&gt;
&lt;p&gt;O Docker é uma plataforma open source (escrita em &lt;strong&gt;Go&lt;/strong&gt;) que trabalha com o conceito de &lt;em&gt;containers&lt;/em&gt;.
A ideia do projeto é simples, se você precisa de uma stack com &lt;strong&gt;ubuntu&lt;/strong&gt;, &lt;strong&gt;python&lt;/strong&gt;, &lt;strong&gt;nginx&lt;/strong&gt; e &lt;strong&gt;supervisor&lt;/strong&gt; por exemplo, você pode colocar tudo isso em um container e deixar esse container pronto para &lt;em&gt;subir&lt;/em&gt; a qualquer hora, sem que seja necessário instalar esses aplicativos novamente.
Pensando dessa forma, o conceito pode se confundir com o conceito de virtualização, porém, o funcionamento é muito diferente.
Enquanto que em uma máquina virtual, possuimos um S.O. completo e isolado, no Docker, aproveitamos o kernel do S.O. hospedeiro, fazendo com isso com que o processo seja muito mais rápido mas sem perder o isolamento dos arquivos e dos processos.&lt;/p&gt;
&lt;p align="center"&gt;
    &lt;img src="/images/docker_vs_vm.png"&gt;
&lt;/p&gt;

&lt;p&gt;Para que isso seja possível, o docker utiliza o &lt;a href="https://linuxcontainers.org/"&gt;Linux Containers&lt;/a&gt; para ter acesso aos recursos do S.O. e também utiliza o &lt;a href="http://aufs.sourceforge.net/"&gt;AuFS&lt;/a&gt; para controlar o sistema de arquivos.&lt;/p&gt;
&lt;h3&gt;Instalado o Docker&lt;/h3&gt;
&lt;p&gt;Chega de conversa fiada, vamos para a prática, afinal, &lt;em&gt;talk is cheap&lt;/em&gt;.
Para instalar o Docker no ubuntu, basta instalar o pacote &lt;code&gt;docker.io&lt;/code&gt; através do &lt;code&gt;apt-get&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine:~$ sudo apt-get install docker.io
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para confirmar se a instalação foi bem sucedida, utilize o comando &lt;code&gt;docker version&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine:~$ sudo docker version
Client version: &lt;span class="m"&gt;1&lt;/span&gt;.0.1
Client API version: &lt;span class="m"&gt;1&lt;/span&gt;.12
Go version &lt;span class="o"&gt;(&lt;/span&gt;client&lt;span class="o"&gt;)&lt;/span&gt;: go1.2.1
Git commit &lt;span class="o"&gt;(&lt;/span&gt;client&lt;span class="o"&gt;)&lt;/span&gt;: 990021a
Server version: &lt;span class="m"&gt;1&lt;/span&gt;.0.1
Server API version: &lt;span class="m"&gt;1&lt;/span&gt;.12
Go version &lt;span class="o"&gt;(&lt;/span&gt;server&lt;span class="o"&gt;)&lt;/span&gt;: go1.2.1
Git commit &lt;span class="o"&gt;(&lt;/span&gt;server&lt;span class="o"&gt;)&lt;/span&gt;: 990021a
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;Para utilizar o Docker é necessário acesso de root.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Criando uma imagem de um container&lt;/h3&gt;
&lt;p&gt;Agora iremos criar uma imagem de um container do docker para aplicações &lt;code&gt;WSGI&lt;/code&gt; com Python (&lt;em&gt;python2.7&lt;/em&gt;, &lt;em&gt;pip&lt;/em&gt; e &lt;em&gt;virtualenv&lt;/em&gt;), Nginx, Gunicorn e Supervisor instalados.
Esse container será baseado na imagem do &lt;strong&gt;Ubuntu&lt;/strong&gt;.&lt;/p&gt;
&lt;h4&gt;Ubuntu&lt;/h4&gt;
&lt;p&gt;As imagens dos containers do docker são armazenadas no &lt;strong&gt;Docker Hub&lt;/strong&gt; e podem ser baixadas através do comando &lt;code&gt;docker pull&lt;/code&gt; (veremos mais sobre o &lt;em&gt;docker hub&lt;/em&gt;).
Para baixar a imagem do ubuntu, basta executar o comando a seguir.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine:~$ sudo docker pull ubuntu:14.04
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;No comando acima, realizamos o download da imagem do ubuntu na &lt;em&gt;tag&lt;/em&gt; 14.04.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Para testar se o download da imagem foi bem sucedido, iremos executar uma instrução dentro do container do ubuntu, através do comando &lt;code&gt;docker run&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine:~$ sudo docker run ubuntu:14.04 cat /etc/lsb-release
&lt;span class="nv"&gt;DISTRIB_ID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;Ubuntu
&lt;span class="nv"&gt;DISTRIB_RELEASE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;14&lt;/span&gt;.04
&lt;span class="nv"&gt;DISTRIB_CODENAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;trusty
&lt;span class="nv"&gt;DISTRIB_DESCRIPTION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Ubuntu 14.04.1 LTS&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Essa instrução irá executar o comando &lt;code&gt;cat /etc/lsb-release&lt;/code&gt; dentro do container do ubuntu.
Se você conseguiu executar esse comando com sucesso, parabéns, você já está utilizando o Docker :).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Se você tiver algum problema para executar o comando &lt;code&gt;docker pull&lt;/code&gt; adicione ao final do arquivo &lt;code&gt;/etc/resolv.conf&lt;/code&gt; a linha &lt;code&gt;nameserver 8.8.8.8&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Fluxo de criação do container&lt;/h4&gt;
&lt;p&gt;Antes de prosseguirmos é importante entender o fluxo de criação dos containers.
O Docker é muito semelhante ao &lt;strong&gt;GIT&lt;/strong&gt; em termos de fluxo de trabalho.
Por padrão o docker &lt;strong&gt;não&lt;/strong&gt; efetiva os comandos que são executados em um container.
Para que as alterações sejam efetivadas é necessário realizar um &lt;code&gt;commit&lt;/code&gt; dessas alterações.
Isso é excelente para realizar experimentos, pois, imagine que você pode acessar um container, instalar um aplicativo qualquer, realizar diversos teste e sair do container, desta forma as alterações feitas somente serão afetivadas se o comando &lt;code&gt;docker commit&lt;/code&gt; for executado.&lt;/p&gt;
&lt;p&gt;Veremos isso na prática ao instalar nossa stack em nosso container.&lt;/p&gt;
&lt;h4&gt;Criando a Stack&lt;/h4&gt;
&lt;p&gt;Agora que já temos a imagem base para criar nosso container, podemos dar sequência.
Como iremos instalar diversos aplicativos, faremos do modo mais simples, instalaremos pelo bash do container.
Para iniciar o bash de um container, execute o comando &lt;code&gt;docker run -t -i IMAGEM /bin/bash&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine:~$ sudo docker run -t -i ubuntu:14.04 /bin/bash
root@4e0ba33ccad5:/#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Assim será iniciado o bash do container e neste ponto não tem muito segredo, basta instalar os aplicativos.
Começaremos pelos aplicativos que são instalados através do &lt;code&gt;apt-get&lt;/code&gt; (&lt;em&gt;python&lt;/em&gt;, &lt;em&gt;pip&lt;/em&gt; e &lt;em&gt;nginx&lt;/em&gt;).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@4e0ba33ccad5:/# apt-get update
root@4e0ba33ccad5:/# apt-get install -y python python-pip nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Com o python e o pip instalado, agora podemos instalar o &lt;em&gt;virtualenv&lt;/em&gt;, o &lt;em&gt;gunicorn&lt;/em&gt; e o &lt;em&gt;supervisor&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@4e0ba33ccad5:/# pip install virtualenv supervisor gunicorn
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para sair do container use o comando &lt;code&gt;exit&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;Realizando commit da alterações&lt;/h4&gt;
&lt;p&gt;Para que essa alterações sejam efetivadas em nosso container (gerando assim uma nova imagem), devemos executar &lt;em&gt;commit&lt;/em&gt;.
O comando &lt;code&gt;docker commit&lt;/code&gt; possui a seguinte sintaxe.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker commit &lt;span class="o"&gt;[&lt;/span&gt;OPÇÕES&lt;span class="o"&gt;]&lt;/span&gt; CONTAINER &lt;span class="o"&gt;[&lt;/span&gt;REPOSITORIO&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Porém, sabemos que o nome da imagem é &lt;code&gt;ubuntu:14.04&lt;/code&gt; mas não sabemos a identificação do container que criamos.
Para saber qual é a identificação do ultimo container criado, execute o comando &lt;code&gt;docker ps -l&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine:~$ sudo docker ps -l
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
4e0ba33ccad5        ubuntu:14.04        /bin/bash           &lt;span class="m"&gt;22&lt;/span&gt; minutes ago      Exited &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="m"&gt;11&lt;/span&gt; minutes ago                       focused_mayer
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Segundo o resultado do comando &lt;code&gt;docker ps&lt;/code&gt; o ID do nosso container é &lt;code&gt;4e0b&lt;/code&gt; (só precisaremos dos 4 primeiros digitos).
Sendo assim, para finalmente realizar o commit, utilizaremos o comando a seguir.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine:~$ sudo docker commit 4e0b wsgi-stack
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Com o comando acima, estamos criando uma nova imagem chamada &lt;code&gt;wsgi-stack&lt;/code&gt; com o conteúdo das alterações que realizamos anteriormente.
Para conferir se tudo funcinou corretamente, vamos executar o comando &lt;code&gt;python --version&lt;/code&gt; em nosso novo container.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine:~$ sudo docker run wsgi-stack python --version
Python &lt;span class="m"&gt;2&lt;/span&gt;.7.6
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Com isso nossa imagem &lt;strong&gt;wsgi-stack&lt;/strong&gt; já está concluída e pronta para o uso, mas antes de efetivamente colocarmos uma aplicações para rodar nela, veremos uma forma mais fácil de criar imagens do docker, através do &lt;strong&gt;Dockerfile&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Dockerfile&lt;/h3&gt;
&lt;p&gt;Um &lt;code&gt;Dockerfile&lt;/code&gt; é um script que automatiza a criação de imagens do docker.
Podemos simplificar a criação da imagem &lt;code&gt;wsgi-stack&lt;/code&gt; que criamos anteriormente com o seguinte &lt;code&gt;Dockerfile&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; ubuntu:14.04&lt;/span&gt;

&lt;span class="k"&gt;MAINTAINER&lt;/span&gt;&lt;span class="s"&gt; Diego Garcia &amp;lt;drgarcia1986@gmal.com&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get update
&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get install -y python python-pip nginx
&lt;span class="k"&gt;RUN&lt;/span&gt; pip install virtualenv gunicorn supervisor
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para criar a imagem baseado no Dockerfile, basta executar o comando &lt;code&gt;docker build&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine:~$ sudo docker build -t wsgi-stack .
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;O &lt;code&gt;.&lt;/code&gt; (ponto) indica que o &lt;code&gt;Dockerfile&lt;/code&gt; está no mesmo diretório onde o comando &lt;code&gt;docker build&lt;/code&gt; está sendo executado.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Basicamente o comando acima cria uma imagem chamada &lt;code&gt;wsgi-stack&lt;/code&gt; baseada no &lt;code&gt;Dockerfile&lt;/code&gt; que está presente no mesmo diretório.&lt;/p&gt;
&lt;h4&gt;Comandos do Dockerfile&lt;/h4&gt;
&lt;p&gt;O Dockerfile é uma ferramenta muito poderosa para a criação de imagens do docker.
Veja alguns comandos que podem ser utilizados no Dockerfile.&lt;/p&gt;
&lt;h5&gt;FROM&lt;/h5&gt;
&lt;p&gt;Primeira instrução, define a imagem base.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; ubuntu14:04&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;MAINTAINER&lt;/h5&gt;
&lt;p&gt;Especifica o autor da imagem.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;MAINTAINER&lt;/span&gt;&lt;span class="s"&gt; Foo foo@bar.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;RUN&lt;/h5&gt;
&lt;p&gt;Equivalente ao comando &lt;code&gt;docker run&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get install python
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;ENV&lt;/h5&gt;
&lt;p&gt;Define uma variável de ambiente.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ENV&lt;/span&gt;&lt;span class="s"&gt; PORT=8000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;EXPOSE&lt;/h5&gt;
&lt;p&gt;Expõe portas.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;EXPOSE&lt;/span&gt;&lt;span class="s"&gt; 8000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;ADD&lt;/h5&gt;
&lt;p&gt;Copia arquivos do host hospedeiro para dentro da imagem.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ADD&lt;/span&gt;&lt;span class="s"&gt; foo.txt /bar/foo.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;ENTRYPOINT&lt;/h5&gt;
&lt;p&gt;Permite que a imagem seja executada como uma aplicativo (a partir da linha de comando especificada).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ENTRYPOINT&lt;/span&gt;&lt;span class="s"&gt; [&amp;quot;python&amp;quot;, &amp;quot;app.py&amp;quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;CMD&lt;/h5&gt;
&lt;p&gt;Comando que será executado quando a execução do container for acionada.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CMD&lt;/span&gt;&lt;span class="s"&gt; [&amp;quot;supervisord&amp;quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;DockerHub&lt;/h3&gt;
&lt;p&gt;O DockerHub é uma espécie de &lt;em&gt;GitHub&lt;/em&gt; do Docker.
Nele você pode criar uma conta e armazenar suas imagens do Docker, assim como usufluir das imagens de outros usuários.
Em nosso exemplo, utilizamos a imagem do &lt;em&gt;ubuntu&lt;/em&gt; que está armazenada no DockerHub, através do comando &lt;code&gt;docker pull ubuntu&lt;/code&gt; e através do &lt;code&gt;FROM ubuntu&lt;/code&gt; do Dockerfile.
Assim como no GitHub, o endereço das imagens é sempre &lt;code&gt;ususário/imagem&lt;/code&gt; com exceção das imagens padrão (como é o caso da imagem do ubuntu).&lt;/p&gt;
&lt;h4&gt;Enviando uma imagem para o Docker Hub&lt;/h4&gt;
&lt;p&gt;Para enviarmos nossa imagem &lt;code&gt;wsgi-stack&lt;/code&gt; para o DockerHub, primeiro é necessario &lt;a href="https://hub.docker.com/account/signup/"&gt;criar uma conta&lt;/a&gt; no serviço e depois fazer &lt;em&gt;login&lt;/em&gt; no aplicativo do Docker.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine:~$ sudo docker login
Username: drgarcia1986
Password:
Email: drgarcia1986@gmail.com
Login Succeeded
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Agora para enviar a imagem para o DockerHub, basta utilizar o comando &lt;code&gt;docker push [IMAGEM]&lt;/code&gt;, porém, o nome da imagem deve serguir o padrão &lt;code&gt;user/image&lt;/code&gt; e nossa imagem está com o nome de &lt;code&gt;wsgi-stack&lt;/code&gt;, para resolver essa questão, podemos criar uma &lt;code&gt;tag&lt;/code&gt; da imagem com o nome no padrão esperado pelo Docker Hub.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine:~$ sudo docker tag wsgi-stack drgarcia1986/wsgi-stack
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;E finalmente enviar nossa imagem para o DockerHub.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine~$ sudo docker push drgarcia1986/wsgi-stack
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pronto, agora sempre que for preciso um docker com &lt;em&gt;python2.7&lt;/em&gt;, &lt;em&gt;pip&lt;/em&gt;, &lt;em&gt;virtualenv&lt;/em&gt;, &lt;em&gt;nginx&lt;/em&gt;, &lt;em&gt;supervisor&lt;/em&gt; e &lt;em&gt;gunicorn&lt;/em&gt;, basta fazer um pull da imagem &lt;em&gt;drgarcia1986/wsgi-stack&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user@machine~$ sudo docker pull drgarcia1986/wsgi-stack
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Em uma segunda parte desse artigo veremos como executar uma aplicação web dentro de um conteiner e como automatizar ainda mais a criação de imagens do Docker através do ~Fig~ &lt;strong&gt;docker compose&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Referências&lt;/strong&gt;&lt;br&gt;
&lt;a href="https://www.docker.com/"&gt;Site Oficial&lt;/a&gt;&lt;br&gt;
&lt;a href="http://docs.docker.com/"&gt;Documentação oficial&lt;/a&gt;&lt;/p&gt;</content><category term="docker"></category><category term="devops"></category><category term="linux"></category><category term="python"></category></entry></feed>